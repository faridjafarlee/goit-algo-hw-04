# goit-algo-hw-04 — Алгоритми сортування

## Завдання
Порівняти за часом виконання:
- сортування вставками (Insertion sort)
- сортування злиттям (Merge sort)
- Timsort (вбудований `sorted` у Python)

Час вимірюється модулем `timeit` на різних типах наборів даних.

## Як запустити
```bash
python sorting_benchmark.py


(Опційно)
python merge_k_lists.py



## Набори даних

У тестах використано такі типи вхідних масивів:

- **Random** — випадкові значення
- **Already sorted** — вже відсортований масив
- **Reversed** — відсортований у зворотному порядку
- **Nearly sorted** — майже відсортований (кілька випадкових перестановок)
- **Many duplicates** — багато повторюваних значень

---

## Теоретичні очікування

### Insertion sort
- **Worst / Average:** `O(n^2)`
- **Best (майже відсортовано):** близько `O(n)` (мінімум зсувів)

### Merge sort
- **У всіх випадках:** стабільно `O(n log n)`  
  (не залежить від того, наскільки масив “вже майже відсортований”)

### Timsort (`sorted` у Python)
- **Базово:** `O(n log n)`
- **Адаптивний:** на майже відсортованих даних може наближатися до `O(n)`
- Ключова ідея: знаходить **runs** (вже впорядковані фрагменти),  
  на малих ділянках використовує **insertion sort**, а далі ефективно **merge**-ить ці фрагменти

---

## Емпіричні результати (спостереження)

### Insertion sort
- Дуже швидко деградує при збільшенні `n`, особливо на **Random** і **Reversed** наборах — що відповідає `O(n^2)`.
- На малих масивах і на **Nearly sorted** може бути конкурентним, бо робить мало перестановок.

### Merge sort
- Показує стабільний час і масштабується значно краще, ніж insertion sort — що узгоджується з `O(n log n)`.
- На практиці часто програє `sorted`, бо має накладні витрати: рекурсія, алокації, створення проміжних масивів.

### Timsort (`sorted`)
- У середньому **найшвидший**, а на **Nearly sorted** — особливо помітно.
- Це очікувано: він оптимізований під реальні сценарії, використовує “runs”, комбінує insertion на малих фрагментах і merge для злиття.

---

## Загальний висновок

Комбінація підходів **merge + insertion** і адаптивність до структури даних роблять **Timsort** практично ефективнішим за “чисті” реалізації.

Тому в більшості реальних задач логічно використовувати вбудовані `sorted()` / `.sort()`, а не реалізовувати сортування вручну.




## Необов'язкове завдання: merge_k_lists

### Ідея
Кожен список вже відсортований, тому повне пересортування всіх елементів "з нуля" не потрібне.
Застосовано підхід як у merge sort: попарно зливати відсортовані списки, доки не залишиться один.

### Складність
Нехай:
- k - кількість списків
- N - сумарна кількість елементів у всіх списках

Злиття двох списків довжин a і b виконується за **O(a + b)**.

У підході merge sort:
- кількість рівнів злиття ≈ **log₂(k)**
- на кожному рівні сумарно проходиться приблизно **N** елементів

Отже:
- **Час: O(N log k)**
- **Пам'ять: O(N)** (бо формується новий список-результат)